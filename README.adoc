= atributo{nbsp}{nbsp}{nbsp}image:https://circleci.com/gh/davedoesdev/atributo.svg?style=svg[Build Status,link=https://circleci.com/gh/davedoesdev/atributo] image:https://ci.appveyor.com/api/projects/status/pu8lp7rsjxswy9t0?svg=true[Build Status,link=https://ci.appveyor.com/project/davedoesdev/atributo] image:https://coveralls.io/repos/github/davedoesdev/atributo/badge.svg[Coverage Status,link=https://coveralls.io/github/davedoesdev/atributo] image:https://img.shields.io/npm/v/atributo.svg[NPM version,link=https://www.npmjs.com/package/atributo]
:prewrap!:
:toc:
:toclevels: 3
:toc-placement: preamble

Node.js module for managing allocation of job IDs across a variable number of
instance IDs.

A typical use would be to allocate work across a number of worker processes.
Job allocations are stored in a SQLite database which any worker (instance)
can access.

You can add a new instance ID and jobs will start to be allocated to it.
You can mark an instance ID as unavailable and no further jobs will be allocated
to it. You can then wait until an instance ID has no jobs allocate to it before
removing it.

This is useful if your jobs are 'sticky', i.e. a job must remain attached to the
instance which started it. A job ID remains allocated to an instance ID even if
a new instance ID is added which would otherwise have been allocated the job
ID. You have to deallocate the job ID explicitly to get it reassigned.

API documentation is available http://rawgit.davedoesdev.com/davedoesdev/atributo/master/docs/index.html[here].

== Example

[source,javascript]
----
const { Atributo } = require('atributo'),
      async = require('async'),
      assert = require('assert');

// Open the database file
new Atributo({ db_filename: 'atributo.sqlite3' }).on('ready', function () {
    async.waterfall([

        // Make instances available
        cb => this.available('instance0', cb),
        cb => this.available('instance1', cb),

        // List instances
        cb => this.instances(cb),
        (instances, cb) => {
            assert.deepStrictEqual(instances, [
                { id: 'instance0', available: true },
                { id: 'instance1', available: true }
            ]);
            cb();
        },

        // Allocate jobs
        cb => this.allocate('job0', cb),
        (persisted, instance_id, cb) => {
            assert(persisted); // <1>
            assert.strictEqual(instance_id, 'instance1');
            cb();
        },
        cb => this.allocate('job1', cb),
        (persisted, instance_id, cb) => {
            assert(persisted); // <1>
            assert.strictEqual(instance_id, 'instance0');
            cb();
        },

        // List jobs for each instance
        cb => this.jobs('instance0', cb),
        (jobs, cb) => {
            assert.deepStrictEqual(jobs, ['job1']);
            cb();
        },
        cb => this.jobs('instance1', cb),
        (jobs, cb) => {
            assert.deepStrictEqual(jobs, ['job0']);
            cb();
        },

        // Check if instance has jobs
        cb => this.has_jobs('instance0', cb),
        (has_jobs, cb) => {
            assert(has_jobs);
            cb();
        },

        // Get instance for job
        cb => this.instance('job1', cb),
        (instance_id, cb) => {
            assert.strictEqual(instance_id, 'instance0');
            cb();
        },

        // Make instance unavailable but don't remove it
        cb => this.unavailable('instance0', false, cb),

        // Check instance is unavailable
        cb => this.instances(cb),
        (instances, cb) => {
            assert.deepStrictEqual(instances, [
                { id: 'instance0', available: false },
                { id: 'instance1', available: true }
            ]);
            cb();
        },

        // Check existing allocation to unavailable instance
        cb => this.allocate('job1', cb),
        (persisted, instance_id, cb) => {
            assert(!persisted); // <2> 
            assert.strictEqual(instance_id, 'instance0');
            cb();
        },

        // Deallocate existing allocation
        cb => this.deallocate('job1', cb), // <3>

        // Re-allocate job
        cb => this.allocate('job1', cb),
        (persisted, instance_id, cb) => {
            assert(persisted); // <1>
            assert.strictEqual(instance_id, 'instance1');
            cb();
        },

        // Remove instance and its allocated jobs
        cb => this.unavailable('instance0', true, cb),

        // Check instance has been removed
        cb => this.instances(cb),
        (instances, cb) => {
            assert.deepStrictEqual(instances, [
                { id: 'instance1', available: true }
            ]);
            cb();
        },

        // Close database
        cb => this.close(cb)

    ], assert.ifError);
});
----
<1> This is a new allocation persisted to the database in this call.
<2> This is an allocation which already existed in the database before the
    instance was made unavailable.
<3> The allocation is removed from the database.

== Allocator

// plus explain default algorithm
// TODO: show override when know instance ID so know when to start job

== Installation

[source,bash]
----
npm install atributo
----

== Licence

link:LICENCE[MIT]

== Test

[source,bash]
----
grunt test
----

== Lint

[source,bash]
----
grunt lint
----

== Coverage

[source,bash]
----
grunt coverage
----

https://istanbul.js.org/[Istanbul] results are available
http://rawgit.davedoesdev.com/davedoesdev/atributo/master/coverage/lcov-report/index.html[here].

Coveralls page is https://coveralls.io/r/davedoesdev/atributo[here].
